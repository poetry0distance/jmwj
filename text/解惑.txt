1.threadLocal:
  内存泄露：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄露，而不是弱引用。
  解决思路：每次完成ThreadLocal都调用remove方法清除数据 ；将ThreadLocal变量定义成private static 这样就一直存在ThreadLocal的强引用，也就
保证了任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而进行清除掉。
  父子线程间的通信：InheritableThreadLocal
    原因：
        1.在创建InheritableThreadLocal对象的时候赋值给线程的t.inheritableThreadLocals变量。
	2.在创建新线程的时候会check父线程中t.inheritableThreadLocals变量是否为null，如果不为null则copy一份ThreadLocalMap到子线程的
t.inheritableThreadLocals成员变量中。
	3.因为复写了getMap(Thread) 和 CreateMap()方法，所以get值的时候，就可以在getMap的时候就会从t.inheritableThreadLocals中拿到map对象，
从而实现了可以拿到父线程ThreadLocal中的值。

2.jmm：(后续理解)

3.synchronized:
  基本原理：synchronized 使用独占锁机制
  代码块：
	每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
	1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
	2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
	3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
  同步方法：
	从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），
	不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 
	ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方
	法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。

  synchronized与ReentrantLocal的区别：（ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁）
	相似点：都是加锁方式同步，都是阻塞式的同步。
	功能区别：synchronized是java语言的关键字，是原生语法层面的互斥。需要jvm实现，而ReetrantLocal是jdk 1.5之后提供的API层面的互斥锁，需要lock
	和unlock方法配合try/finally语句块来完成。锁的细粒度和灵活性，ReetrantLocal优于synchronized。
	性能区别：ynchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，都可用情况下官方建议使用synchronized
	ReentrantLocal:
		1.等待可中断 通过lock.lockInterruptibly()来实现这个机制。
		2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获取锁。synchronized是非公平锁。
		3.锁绑定多个条件。一个ReentrantLock对象可以同时绑定多个对象。ReenTrantLock提供了一个Condition（条件）类，
		用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。


4.ArrayList线程不安全体现：add方法 elementData[size++] = e;不是原子操作。
  ArrayList 和 LinkedList区别:
    1.ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合
    2.对于随机访问，ArrayList优于LinkedList
    3.对于插入和删除操作，LinkedList优于ArrayList
    4.LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素

5.synchronized锁升级过程：偏向锁--> 轻量级锁 --> 重量级锁

6.垃圾回收期有哪些：新生代回收机，老年代回收器，堆回收器
	serial：使用复制算法。单线程  ――》多线程版本 parNew。
	Parallel Scavenge：多线程，以吞吐量优先的收集器。
	Parallel Old：是parallel的老生代版本，吞吐量优先的收集器。
	CMS：以获得最短停顿时间为目标的收集器。
	  缺点：对cpu资源要求敏感；无法清除浮动垃圾；会产生大量的空间碎片
	G1：一种兼顾吞吐量和停顿时间的GC实现。
	  运行过程：
		1.初始标记
		2.并发标记
		3.重新标记
		4.筛选回收：首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。
		这个阶段可以与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的。
   gc Root:
	1.通过System Class Loader 或者 Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root
	2.处于激活状态的线程
	3.栈中的对象
	4.本地方法栈中JNI（Native）的对象
	5.JNI中的全局对象
	6.正在被用于同步的各种锁对象
	7.JVM自身持有的对象，如系统类加载器等。

7.垃圾回收算法
  1.标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
  2.标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存
  3.复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，
	      然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半
  4.分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

8.jvm：
  1.调优工具：JDK的bin目录下的  jconsole 和 jvisualvm （常用）
  2.jvm内存模型 https://www.jianshu.com/p/0ecf020614cb
    线程私有内存：
	|-程序寄存器：
	|-java栈：
	|-本地方法栈：
    线程共享内存
	|-java堆
	|-本地方法区
    直接内存
9.线上问题：cpu跑满，top查看暂用最高的 pid --》top Hp pid 找到占比最高的线程id  -->线程id 转十六进制 printf "%x\\n" tid 
--》jstack查出该线程栈信息 jstack pid|grep tid -A 100

  也可以导出dump日志分析

10.类加载：https://www.jianshu.com/p/1e4011617650
	1.实例化对象时
	2.通过类名调用静态变量时。


11.SpringBoot启动流程：
   1.第一步进行SpringApplication的初始化模块，配置一些基本信息，环境变量、资源、构造器、监听器。
   2.第二步实现应用具体的启动方案，启动流程的监听模块、加载配置环境模块、创建上下文环境模块。
   3.第三部自动化配置。
 springBoot和springMVC的区别：
	Spring 是一个“引擎”；
	Spring MVC 是基于Spring的一个 MVC 框架；
	Spring Boot 是基于Spring4的条件注册的一套快速开发整合包

  springMVC原理：前端请求 调用前端控制器 DispatcherServlet ;DispatcherServlet 调用 HandlerMapping处理器映射器；处理器映射器找到具体的处理器生成处理器对象
及处理器拦截器返回个DispatcherServlet；DispatcherServlet调用HandlerAdapter处理器适配器；HandlerAdapter调用具体的Controller；controller处理结束返回
modelandview；HandlerAdapter将modelAndView反馈给DispatcherServlet；DispatcherServlet调用ViewReslover视图解析器；ViweReslover返回具体的view
DispatcherServlet根据具体的view进行视图渲染；响应客户。

数据库事务实现：redo log 重做日志 记录被修改后的数据。
		undo log 回滚日志 记录数据被修改前的信息，记录的是数据的逻辑变化，用于保障未提交事务的原子性。
		mysql锁操作，共享锁（读锁），排他锁（写锁）
		mvcc，在mysql中实现依赖的是undo log的read view

事务的传播特性：7种
		1.支持当前事务，则使用当前事务，不存在则新建
		2.新建事务，存在当前事务则当前事务挂起
		3.支持当前事务，不存在则异常
		4.支持当前事务，当前没有事务则以非事物的方式运行
		5.以非事物的方式执行操作，如果存在当前事务，则当前事务挂起
		6.以非事务的方式执行操作，如果存在当前事务，则抛出异常
		7.如果没有就新建事务，如果有就在当前事务中嵌套其他事务。

redis：
  跳表：时间复杂度 O(logn) 空间复杂度：类似于等比数列的结构。O(n)
  过期策略：定时过期，惰性过期，定期过期。过期策略用于设置数据的过期时间
  内存淘汰策略：6种 淘汰策略用于内存不足时的清除数据策略
    1.当内存不足以容纳新写入的数据时，报错  noeviction
    2.当内存不足以容纳新写入的数据时，在键空间中，移除最近最少使用的key allkeys-lru
    3.当内存不足以容纳新写入的数据时，在键空间中，随机移除一个key allkeys-random
    4.当内存不足以容纳新写入的数据时，在设置过期的键空间中，移除最近最少使用的 volatile-lru
    5.当内存不足以容纳新写入的数据时，在设置过期的键空间中，随机移除 volatile-random
    6.当内存不足以容纳新写入的数据时，在设置过期的键空间中，有更早过期的优先移除 volatile-ttl
  过期键的清除策略：
    被动删除：当读写一个过期的key时，触发惰性删除策略，直接删除这个过期的key
    主动删除：由于惰性策略无法保证冷数据被及时删掉，所以会定期淘汰一批已过期的key
    当前已用内存超过maxmemory限定时，触发主动清理策略：

